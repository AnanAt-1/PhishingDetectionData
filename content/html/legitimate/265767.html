<html><head>
<title>TOM: Reasons</title>
</head>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN="top">
      <TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD ALIGN="right"><FONT SIZE="+2"
	COLOR="#ffffff"><B>TOM</B></FONT></TD></TR></TABLE>
    </TD>
    <TD ROWSPAN="4" VALIGN="top" BGCOLOR="#000000"><FONT SIZE="-3"
	COLOR="#000000">&nbsp;</FONT></TD>
    <TD VALIGN="top"><TABLE BGCOLOR="#000000" WIDTH="100%"
	CELLSPACING="0" CELLPADDING="5" BORDER="0"><TR><TD><FONT
	SIZE="+2" COLOR="#ffffff"><B>

Reasons for TOM
</B></FONT></TD>
</TR></TABLE>
    </TD>
    <TD ROWSPAN="4" VALIGN="top" BGCOLOR="#000000"><FONT SIZE="-3"
	COLOR="#000000">&nbsp;</FONT></TD>
    <TD VALIGN="top">
      <TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD ALIGN=left><FONT SIZE="+2"
	COLOR="#ffffff"><B>&nbsp;</B></FONT></TD></TR></TABLE>
    </TD>
  </TR>
  <TR>
    <TD ROWSPAN="2" VALIGN="top">
      <TABLE>
       <TR><TD ALIGN="right"><A href="../">TOM&nbsp;Home</A><br>
        <A href="../tasks.shtml">TOM&nbsp;Tasks</A></td></tr>
       <tr><td><hr noshade></td></tr>
       <TR><TD ALIGN="right"><A href="../faq/">FAQ</A><br>
	<A href="../news.shtml">News</A><br>
        <A href="../highlights/">Highlights</A><br>
        <A href="../papers/">Publications</A><br>
        <A href="../doc/">Documentation</A><br>
        <A href="../resources/">Download&nbsp;TOM</A><br>
        <A href="../sw/">TOM&nbsp;Software</A><br>
        <A href="http://sferik.cubik.org/bugs/">Bug Database</A><br>
        <a href="../mailings.shtml">Mailing Lists</a></td></tr>
       <tr><td><hr noshade></td></tr>
       <TR><TD ALIGN="right"><b>Mail:</b><br>
tiggr at gerbil.org</td></tr>
       <tr><td><hr noshade></td></tr>
      </TABLE>
    </TD>
    <TD VALIGN="top">

    </TD>
  <td rowspan=2 valign=top>
  <table>
   <tr><td><font size=-1><b>Short Cuts:</b></font></td></tr>
   <tr><td><font size=-1>
    <a href="/tom/tesla/">Tesla</a></font>
    <br><a href="/tom/sw/tomgtk/">TOM/Gtk</a>
    <br><a href="/tom/sw/gp/">GP</a></font>
    <br><a href="/tom/sw/mu/">MU</a></font>
   </td></tr>
   <tr><td><hr noshade></td></tr>
   <tr><td><font size=-1><b>Snapshots:</b></font></td></tr>
   <tr><td><font size=-1><a href="/ftp/pub/tom/stable/">all of
     'em</a>
<br><a href="/ftp/pub/tom/stable/tom-[an error occurred while processing this directive].tar.gz">tom&nbsp;[an error occurred while processing this directive]
<br><a href="/ftp/pub/tom/stable/tesla-[an error occurred while processing this directive].tar.gz">tesla&nbsp;[an error occurred while processing this directive]
<br><a href="/ftp/pub/tom/stable/mu-[an error occurred while processing this directive].tar.gz">mu&nbsp;[an error occurred while processing this directive]
<br><a href="/ftp/pub/tom/stable/tomgtk-[an error occurred while processing this directive].tar.gz">tomgtk&nbsp;[an error occurred while processing this directive]
</font></td></tr>
   <tr><td><hr noshade></td></tr>
   <tr><td><font size=-1><b>Released:</b></font></td></tr>
   <tr><td><font size=-1><a href="/ftp/pub/tom/">all of 'em</a>
<br><a href="/ftp/pub/tom/tom-1.1.1.tar.gz">tom&nbsp;1.1.1
<br><a href="/ftp/pub/tom/tomgtk-0.11.tar.gz">tomgtk&nbsp;0.11
<br><a href="/ftp/pub/tom/tesla-0.91.tar.gz">tesla&nbsp;0.91
<br><a href="/ftp/pub/tom/gp-0.5.tar.gz">gp&nbsp;0.5
<br><a href="/ftp/pub/tom/mu-1.0.tar.gz">mu&nbsp;1.0
</font></td></tr>
   <tr><td><hr noshade></td></tr>
   <tr><td><font size=-1><b>Misc:</b></font></td></tr>
   <tr><td><font size=-1><a
     href="http://www.gnu.org/philosophy/gif.html">GIF free NOW!</a></td></tr>
   <tr><td><hr noshade></td></tr>
  </table>
  </dt>
  </TR>
  <TR>
    <TD VALIGN="top">


	Below is a list of problems with (object oriented, procedural)
	programming languages that TOM attempts to solve, or at least
	address.  The list is not exhaustive and TOM undoubtebly comes
	with its own problems solved by other languages.  (This list was
	compiled while TOM was conceived in late 1995, early 1996.  Though
	the wording and reasoning has improved since, this original list
	remains interesting reading.)

<P>
<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Extensibility</B></FONT></TD></TR></TABLE>

<BR>In Smalltalk and Objective-C methods can be added to an already
	existing class, but instance variables can not.  In C++, Eiffel
	and Java a class is defined by its one and only definition.<p>

	In TOM, a class need not be defined by one monolithic definition:
	its definition can be split into multiple parts, called
	extensions.  An extension can add instance and class variables; it
	can declare new superclasses from which to inherit; and it can add
	and replace methods.

	An extension is not a mere compile-time entity; an extension can
	be loaded into a running program for instance to load extensions
	for testing the software.<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Usability</B></FONT></TD></TR></TABLE>
<br>With TOM, the semantics of the language do not change with the
	availability of sources.  Put more strongly, the possibilities of
	the language are not restricted in any way if sources are not
	available or modifiable.  This allows one to adjust library
	classes in case subclassing does not suffice, increasing the
	usability, as opposed to reusability, of the library class.  <p>

	In Cecil a superclass can be added to an existing class, providing
	some of the functionality offered by TOM.

	A counter-example of usability is Eiffel, where the availability
	of only the short form of a class severly hampers the
	possibilities of subclassing.<p>

	As another example, given a C++ library of which one wants to
	replace a class by a different one.  In that case, the member
	variables must remain identical if referred to from within one of
	the other objects in the library.  The same is true for virtual
	methods if invoked from the other objects.  If any of the member
	functions of the class to be replaced is inlined in the other
	objects, the possibility of successfully completing this venture
	within the original goals is further reduced.<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Uniformity</B></FONT></TD></TR></TABLE>
<br>C++ provides signatures, Java calls them interfaces, and Objective-C
	refers to them as protocols.  Apart from some of the more obscure
	problems, such as an Objective-C class object not being able to
	adhere to a protocol, these constructs are orthogonal to the
	normal class hierarchy.  In Java and Objective-C, they provide a
	means for multiple inheritance of interface declaration; in C++ it
	is an attempt to cover some of its many deficiencies.<p>

	In TOM, the functionality of protocols (and signatures and
	interfaces) is simply provided by the class hierarchy itself; it
	follows logically from TOM's use of dynamic binding, multiple
	inheritance, and deferred method declarations.<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Static</B></FONT></TD></TR></TABLE>
<br>TOM is strongly type checked at compile time; various (builtin,
	static) basic types and the (user defined, dynamic) classes are
	discerned.

	Methods are overloaded on both the argument types and the types of
	the return values.  Since multi-dispatching is considered too
	troublesome, especially in the context of dynamic loading, method
	overloading is restricted to what a compiler can guarantee: the
	basic types are discerned and all objects are considered equal.<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Dynamic</B></FONT></TD></TR></TABLE>
<br>At runtime TOM provides full typing information on objects, their
	instance and class variables, and arguments to and return value
	from methods.  All methods are dynamically bound.  Methods are
	provided to read and set instance and class variables given their
	name; to retrieve an object's class; to query a class for its
	position in the inheritance hierarchy; to send an object a message
	of which the selector need not be known at compile time (a bit
	like function pointers in C++, but being dynamically bound much
	more flexible; more like <code>perform</code> in SmallTalk and
	Objective-C, but without restrictions on the types and number of
	arguments).<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT COLOR="#ffffff"><B>Storage
	Management</B></FONT></TD></TR></TABLE>
<br>All objects are allocated from the garbage collected heap.  This
	implies that it is impossible to have problems with dangling
	references, previously valid pointers having become invalid,
	memory leaks, etc.<p>

	In TOM, an object can not be a part of an entity of which the
	lifetime is unrelated to, and possibly shorter than, the lifetime
	of the object.  This containment rule dictates that objects can
	not be allocated from the stack and they can not be part of
	another object.<p>

<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT
	COLOR="#ffffff"><B>Exceptions</B></FONT></TD></TR></TABLE>
<br>In most languages (C++, Java, NeXT's Objective-C libraries, to name
	but a few), an exception handler is executed in its own context
	instead of the context of the exception raiser, implying that it
	is impossible for the handler to <em>direct</em> the actions of
	the condition raiser---the stack has already been unwound and
	nothing can be done about that.<p>

	The TOM exception mechanism is modeled after Common Lisp
	conditions.  A TOM condition can be signaled; if none of the
	condition handlers is interested in handling this condition,
	execution continues in the context of the condition signaler, as
	if the signal were a normal method invocation.  A condition
	handler can direct the condition signaler by setting the value to
	be returned from the signal invocation.  It can also decide to
	perform a non-local exit, the equivalent of a C
	<code>longjmp</code>.<p>

	It is of course possible for a method not to be able to continue
	execution after a condition.  In this case it can force the
	condition to be handled, by raising it instead of signaling.
	Failure to handle a raised condition through a non-local exit
	results in program termination.<p>
<TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0" CELLPADDING="5"
	BORDER="0"><TR><TD><FONT COLOR="#ffffff"><B>Return
	Values</B></FONT></TD></TR></TABLE>
<br>In most procedural object oriented languages, there is an arbitrary
	limit on the number of values a method or function can return.
	This limit is 1, and pointer arguments, struct returns, or other
	tricks are needed to return more than one value.  In Common Lisp,
	multiple-valued returns are possible, but they are special.<p>

	TOM imposes no limit on the number of values that can be returned
	from a method.<p>
<hr>
Up: <a href="./">TOM Documentation</a>
   </TD>
  </TR>
  <TR>
    <TD VALIGN="top">
      <TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0"
	CELLPADDING="3" BORDER="0"><TR><TD ALIGN="right"><FONT SIZE="-1"
	COLOR="#ffffff">&nbsp;</FONT></TD></TR></TABLE>
    </TD>
    <TD VALIGN="top">
      <TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0"
	CELLPADDING="3" BORDER="0"><TR><TD><FONT SIZE="-1"
	COLOR="#ffffff"><B>Copyright &copy; 1997-2002 Programmers Without
	Deadlines</B></FONT></TD></TR></TABLE>
    </TD>
    <TD VALIGN="top">
      <TABLE BGCOLOR="#000000" WIDTH="100%" CELLSPACING="0"
	CELLPADDING="3" BORDER="0"><TR><TD ALIGN="right"><FONT SIZE="-1"
	COLOR="#ffffff">&nbsp;</FONT></TD></TR></TABLE>
    </TD>
  </TR>
</TABLE>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5211214-1");
pageTracker._trackPageview();
</script>

</body></html>

